                  HIGH LEVEL INTRODUCTION
Yes, REST API integration was a core part of my work as a Flutter Developer
Intern. I was responsible for consuming backend APIs, 
handling authentication, parsing responses, managing application state and
displaying dynamic data in the UI. I worked closely with backend 
developers to understand API contracts and ensured smooth, secure, and
efficient data flow between the flutter app and the server.

               WHAT REST API MEANT IN MY PROJECT?
In our project, REST API were used to handle features like user 
authentication, registration, fetching user profiles, listing dynamic 
data, submitting forms, and handling updates. The backend was exposing
APIs in JSON format, and my responsibility was to integrate them correctly 
in flutter and make sure the app behaved reliably in real world 
scenarios like slow internet, API failure or Invalid responses.

             STEP BY STEP DEEP DIVE (THIS IS THE CORE)
   UNDERSTANDING THE API CONTRACT
Before Implementation, I always started by understanding the API contract
- endpoint URL, HTTP method (GET ,POST, PUT, DELETE), headers, request body,
response structure and status codes.

  WHY THIS MATTERS(say confidently):
This reduced integration bugs and helped me map backend responses correctly
to Flutter models.

  CHOOSING THE HTTP APPROACH IN FLUTTER:
In Flutter, I mainly used the 'http' package for REST API calls. For more
cases like interceptors or advanced error handling, I also explored Dio
conceptually.
Typically structure u can explain:
*API service layer           *Model classes           *UI layer
"I followed a clean separation so that API logic never lived directly
inside widgets."

  MAKING API CALLS (GET / POST)
"For GET requests, I fetched data such as lists or user details. 
 For POST requests, I sent form data like login credentials, registration
 details, or OTP verification.".
 What you handled practically:
*Headers (Content-Type, Authorization).
*Request body (JSON encoding).
*Async/await for non blocking UI.

   
  JSON PARSING & MODEL CLASSES (VERY IMPORTANT)
Since APIs returned JSON, I created Dart model clases using 'fromJson' and
'toJson' methods. This ensured type safety and avoided runtime errors.
  You can add:
This also made the code more readable and easier to maintain when the 
response structure changed.
 If interciewer probes:
*Explain handling nested JSON.            *Lists vs Single objects.
*Nullable fields.

  AUTHENTICATION & TOKEN HANDLING:
For authenticated APIs, I handled token based authentication. After login,
the token was stored securely and passed in headers for subsequent API 
calls.
Explain maturity: *Token expiry handling(basic level).
 *Logout clearly tokens            *Unautorized(401) response handling. 

  State Management During API Calls:
I managed API states like loading, success, and errors using proper state
management techniques. while fetching data, I showed loaders, 
on success data was rendered and on failure, meaningful error messages were
displayed.
You can mention: *setState     *GetX/Provider (if used conceptually)
 *Avoiding unnecessary rebuilds.
